// Generated by gencpp from file seagull_autopilot_msgs/AutopilotStatus.msg
// DO NOT EDIT!


#ifndef SEAGULL_AUTOPILOT_MSGS_MESSAGE_AUTOPILOTSTATUS_H
#define SEAGULL_AUTOPILOT_MSGS_MESSAGE_AUTOPILOTSTATUS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <seagull_commons_msgs/SeagullHeader.h>

namespace seagull_autopilot_msgs
{
template <class ContainerAllocator>
struct AutopilotStatus_
{
  typedef AutopilotStatus_<ContainerAllocator> Type;

  AutopilotStatus_()
    : header()
    , orbitRadius(0)
    , trackerStatus(0)
    , timeToWp(0)
    , wpFrom(0)
    , wpTo(0)
    , airBoundaryViolated(false)
    , autopilotEngineKill(false)
    , commsTimeout(false)
    , fligthTimerElapsed(false)
    , fligthTermination(false)
    , gpsTimeout(false)
    , orbiting(false)
    , loopControl1(0)
    , loopControl2(0)
    , loopControl3(0)
    , loopControl4(0)
    , loopControl5(0)
    , loopControl6(0)
    , loopControl7(0)
    , loopControl8(0)
    , loopControlCount(0)
    , userAction0(false)
    , userAction1(false)
    , userAction2(false)
    , userAction3(false)
    , userAction4(false)
    , userAction5(false)
    , userAction6(false)
    , userAction7(false)
    , elapsedTime(0)  {
    }
  AutopilotStatus_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , orbitRadius(0)
    , trackerStatus(0)
    , timeToWp(0)
    , wpFrom(0)
    , wpTo(0)
    , airBoundaryViolated(false)
    , autopilotEngineKill(false)
    , commsTimeout(false)
    , fligthTimerElapsed(false)
    , fligthTermination(false)
    , gpsTimeout(false)
    , orbiting(false)
    , loopControl1(0)
    , loopControl2(0)
    , loopControl3(0)
    , loopControl4(0)
    , loopControl5(0)
    , loopControl6(0)
    , loopControl7(0)
    , loopControl8(0)
    , loopControlCount(0)
    , userAction0(false)
    , userAction1(false)
    , userAction2(false)
    , userAction3(false)
    , userAction4(false)
    , userAction5(false)
    , userAction6(false)
    , userAction7(false)
    , elapsedTime(0)  {
    }



   typedef  ::seagull_commons_msgs::SeagullHeader_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _orbitRadius_type;
  _orbitRadius_type orbitRadius;

   typedef uint8_t _trackerStatus_type;
  _trackerStatus_type trackerStatus;

   typedef uint16_t _timeToWp_type;
  _timeToWp_type timeToWp;

   typedef uint8_t _wpFrom_type;
  _wpFrom_type wpFrom;

   typedef uint8_t _wpTo_type;
  _wpTo_type wpTo;

   typedef uint8_t _airBoundaryViolated_type;
  _airBoundaryViolated_type airBoundaryViolated;

   typedef uint8_t _autopilotEngineKill_type;
  _autopilotEngineKill_type autopilotEngineKill;

   typedef uint8_t _commsTimeout_type;
  _commsTimeout_type commsTimeout;

   typedef uint8_t _fligthTimerElapsed_type;
  _fligthTimerElapsed_type fligthTimerElapsed;

   typedef uint8_t _fligthTermination_type;
  _fligthTermination_type fligthTermination;

   typedef uint8_t _gpsTimeout_type;
  _gpsTimeout_type gpsTimeout;

   typedef uint8_t _orbiting_type;
  _orbiting_type orbiting;

   typedef uint8_t _loopControl1_type;
  _loopControl1_type loopControl1;

   typedef uint8_t _loopControl2_type;
  _loopControl2_type loopControl2;

   typedef uint8_t _loopControl3_type;
  _loopControl3_type loopControl3;

   typedef uint8_t _loopControl4_type;
  _loopControl4_type loopControl4;

   typedef uint8_t _loopControl5_type;
  _loopControl5_type loopControl5;

   typedef uint8_t _loopControl6_type;
  _loopControl6_type loopControl6;

   typedef uint8_t _loopControl7_type;
  _loopControl7_type loopControl7;

   typedef uint8_t _loopControl8_type;
  _loopControl8_type loopControl8;

   typedef uint8_t _loopControlCount_type;
  _loopControlCount_type loopControlCount;

   typedef uint8_t _userAction0_type;
  _userAction0_type userAction0;

   typedef uint8_t _userAction1_type;
  _userAction1_type userAction1;

   typedef uint8_t _userAction2_type;
  _userAction2_type userAction2;

   typedef uint8_t _userAction3_type;
  _userAction3_type userAction3;

   typedef uint8_t _userAction4_type;
  _userAction4_type userAction4;

   typedef uint8_t _userAction5_type;
  _userAction5_type userAction5;

   typedef uint8_t _userAction6_type;
  _userAction6_type userAction6;

   typedef uint8_t _userAction7_type;
  _userAction7_type userAction7;

   typedef uint16_t _elapsedTime_type;
  _elapsedTime_type elapsedTime;


    enum { STATUS_OFF = 0u };
     enum { STATUS_ON = 1u };
     enum { STATUS_AUTO = 2u };
 

  typedef boost::shared_ptr< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> const> ConstPtr;

}; // struct AutopilotStatus_

typedef ::seagull_autopilot_msgs::AutopilotStatus_<std::allocator<void> > AutopilotStatus;

typedef boost::shared_ptr< ::seagull_autopilot_msgs::AutopilotStatus > AutopilotStatusPtr;
typedef boost::shared_ptr< ::seagull_autopilot_msgs::AutopilotStatus const> AutopilotStatusConstPtr;

// constants requiring out of line definition

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace seagull_autopilot_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'seagull_autopilot_msgs': ['/home/ciafa/sharpeye15/sharpeye15_ws/src/seagull_autopilot_msgs/msg'], 'seagull_commons_msgs': ['/home/ciafa/sharpeye15/sharpeye15_ws/src/seagull_commons_msgs/msg'], 'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ba6bd3a788b80b299ef58cd33c2e580f";
  }

  static const char* value(const ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xba6bd3a788b80b29ULL;
  static const uint64_t static_value2 = 0x9ef58cd33c2e580fULL;
};

template<class ContainerAllocator>
struct DataType< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "seagull_autopilot_msgs/AutopilotStatus";
  }

  static const char* value(const ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "seagull_commons_msgs/SeagullHeader header\n\
uint8 orbitRadius\n\
uint8 trackerStatus\n\
uint16 timeToWp\n\
uint8 wpFrom\n\
uint8 wpTo\n\
bool airBoundaryViolated\n\
bool autopilotEngineKill\n\
bool commsTimeout\n\
bool fligthTimerElapsed\n\
bool fligthTermination\n\
bool gpsTimeout\n\
bool orbiting\n\
uint8 loopControl1\n\
uint8 loopControl2\n\
uint8 loopControl3\n\
uint8 loopControl4\n\
uint8 loopControl5\n\
uint8 loopControl6\n\
uint8 loopControl7\n\
uint8 loopControl8\n\
uint8 loopControlCount\n\
	uint8 STATUS_OFF=0\n\
	uint8 STATUS_ON=1\n\
	uint8 STATUS_AUTO=2\n\
bool userAction0\n\
bool userAction1\n\
bool userAction2\n\
bool userAction3\n\
bool userAction4\n\
bool userAction5\n\
bool userAction6\n\
bool userAction7\n\
uint16 elapsedTime\n\
\n\
================================================================================\n\
MSG: seagull_commons_msgs/SeagullHeader\n\
Header header\n\
uint16 vehicleId\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.orbitRadius);
      stream.next(m.trackerStatus);
      stream.next(m.timeToWp);
      stream.next(m.wpFrom);
      stream.next(m.wpTo);
      stream.next(m.airBoundaryViolated);
      stream.next(m.autopilotEngineKill);
      stream.next(m.commsTimeout);
      stream.next(m.fligthTimerElapsed);
      stream.next(m.fligthTermination);
      stream.next(m.gpsTimeout);
      stream.next(m.orbiting);
      stream.next(m.loopControl1);
      stream.next(m.loopControl2);
      stream.next(m.loopControl3);
      stream.next(m.loopControl4);
      stream.next(m.loopControl5);
      stream.next(m.loopControl6);
      stream.next(m.loopControl7);
      stream.next(m.loopControl8);
      stream.next(m.loopControlCount);
      stream.next(m.userAction0);
      stream.next(m.userAction1);
      stream.next(m.userAction2);
      stream.next(m.userAction3);
      stream.next(m.userAction4);
      stream.next(m.userAction5);
      stream.next(m.userAction6);
      stream.next(m.userAction7);
      stream.next(m.elapsedTime);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct AutopilotStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::seagull_autopilot_msgs::AutopilotStatus_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::seagull_commons_msgs::SeagullHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "orbitRadius: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitRadius);
    s << indent << "trackerStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.trackerStatus);
    s << indent << "timeToWp: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.timeToWp);
    s << indent << "wpFrom: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wpFrom);
    s << indent << "wpTo: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wpTo);
    s << indent << "airBoundaryViolated: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.airBoundaryViolated);
    s << indent << "autopilotEngineKill: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.autopilotEngineKill);
    s << indent << "commsTimeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.commsTimeout);
    s << indent << "fligthTimerElapsed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.fligthTimerElapsed);
    s << indent << "fligthTermination: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.fligthTermination);
    s << indent << "gpsTimeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gpsTimeout);
    s << indent << "orbiting: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbiting);
    s << indent << "loopControl1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl1);
    s << indent << "loopControl2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl2);
    s << indent << "loopControl3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl3);
    s << indent << "loopControl4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl4);
    s << indent << "loopControl5: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl5);
    s << indent << "loopControl6: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl6);
    s << indent << "loopControl7: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl7);
    s << indent << "loopControl8: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControl8);
    s << indent << "loopControlCount: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loopControlCount);
    s << indent << "userAction0: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction0);
    s << indent << "userAction1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction1);
    s << indent << "userAction2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction2);
    s << indent << "userAction3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction3);
    s << indent << "userAction4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction4);
    s << indent << "userAction5: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction5);
    s << indent << "userAction6: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction6);
    s << indent << "userAction7: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.userAction7);
    s << indent << "elapsedTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.elapsedTime);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SEAGULL_AUTOPILOT_MSGS_MESSAGE_AUTOPILOTSTATUS_H
